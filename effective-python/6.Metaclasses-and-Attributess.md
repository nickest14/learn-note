# Efficiency Python Note
<hr>

**6. Metaclasses and Attributess**
- Item 44 : 使用清楚的 attributes 取代 setter 及 getter method
    * 用簡單的 public attributes 及避免 用 getter 及 setter 來定義新的 class interfaces
    * 如果需要, 當屬性被存取時, 使用 @property 來定義特別的行為, 但要小心帶來的副作用
    * 使用 @property 時, 確保你的方法速度夠快, 若有包含大量 I/O, DB query 或會造成負面影響時, 用一般的方法就好     
- Item 45 : 考慮 @property 替代重構 attributes
    * 使用 @property 讓現有的 instance attributes 有更多功能, 並邁向更好的 data models
    * 當使用 @property 負擔太大時, 考慮重構 class 和調用的地方

- Item 46 : 使用 descriptors 來讓 @property method 可重複使用
    * @property 缺點為沒辦法在class 中重複使用, 每個 attribute 必須寫自己的邏輯
    * 定義 descriptor class 來重複使用 @property 的行為及驗證
    * 使用 WeakKeyDictionary 確保 descriptor class 不會造成 memory leak
    ```
    from weakref import WeakKeyDictionary


    class Grade:
        def __init__(self):
            self._values = WeakKeyDictionary()

        def __get__(self, instance, instance_type):
            if instance is None:
                return self
            return self._values.get(instance, 0)

        def __set__(self, instance, value):
            if not (0 <= value <= 100):
                raise ValueError(
                    'Grade must be between 0 and 100')
            self._values[instance] = value


    class Exam:
        math_grade = Grade()
        writing_grade = Grade()
        science_grade = Grade()


    first_exam = Exam()
    first_exam.writing_grade = 70
    first_exam.science_grade = 80

    second_exam = Exam()
    second_exam.writing_grade = 60    
    ```
    * 若在 init 直接使用 self._values ＝ ０, \_\_get\_\_ 使用 return self._values 的話, first_exam 及 second_exam 會使用到相同的 Grade instance, 造成結果與預期不一樣, 因為在程式的 lifetime, Grade instance 在第一次被定義時就已經建立了, 不是 Exam 被創建時才建立的
- Item 47 : Begin
    * 使用
    * 
    * 
    ```
    ```
- Item 48 : Begin
    * 使用
    * 
    * 
    ```
    ```
- Item 49 : Begin
    * 使用
    * 
    * 
    ```
    ```                