# Efficiency Python Note
<hr>

**8. Robustness and Performance**

- Item 65: 充分利用每個 block (try/except/else/finally)
    * Try/finally 複合語句使你可以運行乾淨的程式，而不管try塊中是否引發了異常
    * else block 幫助你最小化 try block 的程式碼量, 並在視覺上將成功案例與 try/except block 區分開

- Item 66: 為了可復用的 try/finally behavior, 考慮 contextlib 及 with statements
    * With stattements 實作了 \_\_enter\_\_ 及 \_\_exit\_\_ function
    * 使用 with statment 可以重複使用 try/except 裡的邏輯並減少視覺噪音
    * 內建的 contextlib module 提供了 contextmanager 裝飾器, 讓你的 function 可以輕鬆的使用 with statement
    * 由 context managers 產生的 value, 作為 with statement 的一部分, 讓你的程式直接訪問上下文, 是很有用的
    ```
    from threading import Lock

    lock = Lock()

    with lock:
        # Do something while maintaining an invariant
        ...

    // Is equivalent as below
    try:
        # Do something while maintaining an invariant
        ...
    finally:
    lock.release()   
    ```
    ```
    import logging
    from contextlib import contextmanager


    def my_function():
        logging.debug('Some debug data')
        logging.error('Error log here')
        logging.debug('More debug data')


    @contextmanager
    def debug_logging(level):
        logger = logging.getLogger()
        old_level = logger.getEffectiveLevel()
        logger.setLevel(level)
        try:
            yield
        finally:
            logger.setLevel(old_level)


    with debug_logging(logging.DEBUG):
        print('* Inside:')
        my_function()

    print('* After:')
    my_function()    
    ```

- Item 67: 使用 datetime 取代 time
    * q
    * q
    * 
    ```
    ```    