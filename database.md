# Database Note
<br>

## 資料模型設計
#### 正規化: 可消除重復複資料, 並減少處理吃料時所需的資源 (降低相依性)  

``` 欄代價高, 列代價低 ```

##### 正確的表設計, 會將個別屬性放在獨立的欄中, 使filter更容易
##### 確認欄位資料合理

* 第一正規化(1NF): 為了排除重複群的出現, 並要有primary key
* 第二正規化(2NF): 必須去除部份相依性
* 第三正規化(3NF): 要找出屬性集合間的直接相依性, 若有間接相依性, 則須去除

#### 凡被參考的資料即為父資料表, 且父資料表一定是其主索引鍵屬性被參考
<hr>
<br>

## 程式化與索引設計
#### 檢查要索引的欄式是否帶有空值, 如果想要搜尋空值, 但欄大部分的值可能是NULL, 最好不要對該欄增加索引

#### 每個資料庫系統對索引的空值支援不同, 建構可能帶有空值的欄的索引前要確保知道資料庫系統的選項

#### <font color="#660000">索引掃描與資料表掃描</font> 發生於資料庫引擎必須掃描索引或資料頁以找出紀錄, 相對於以索引搜尋符合查詢條件的紀錄, 資料越多掃描索引要花的時間越久
* 分析資料以建構提昇效能的索引
* 確保所建構的索引會被使用


#### 沒有寫好 where 句子是低效能查詢的主因 
* WHERE 及 SELECT 句子中的欄是否有索引會影響查詢的效能
* 兩個資料表的欄是否有索引會影響連接的效能
* 索引會影響order by 句子的效能
* 存在多個索引會影響寫入操作

#### (Trigger 觸發器) 由於在構建資料表時透過使用約束提供的DRI和使用內建功能的計算列提供的性能通常比較好, 因此建議對於計算列預設使用約束或內建功能
#### 只在絕對需要時使用觸發器

#### 以過濾索引包括或排除一組資料
* 過濾索引在索引只用於一小部分列時對節省空間有幫助
* 過濾索引可用於實作一部份列(例如WHERE active = 'y')的獨特約束
* 過濾索引可用於避免排序操作
* 分割資料表可提供類似過濾索引無需維護其他索引的好處

#### 宣告約束代替程式檢查 
* 考慮使用約束藍強制資料完整性
* 查詢最佳化程序可使用約束定義建構高效能的查詢執行計畫
#### 資料表的索引越多, 更新的速度會越慢
* 不要濫用索引
* 分析資料庫的預期使用以確保過濾索引只在合理的地方使用
<hr>
<br>

## 不能改變設計時
#### 使用檢視表簡化無法改變的部分
* 使用檢視表建構容易使用的資料結構
* 使用檢視表限制使用者可檢視的資料
* 使用檢視表隱藏與重複使用複雜的查詢
* 使用檢視表彙整產生報表的不同資料表
* 使用檢視表

#### 使用ETL將非關連式資料轉成資訊

#### 建構彙整資料表並加以維護
* 儲存彙整資料可減少匯總所需的處理
* 使用資料表儲存匯總資料可讓匯總資料欄索引茶查尋更有效率
* 匯總適用於較靜態的資料表, 若經常更動, 成本過高
* 觸發器可用來執行匯總,但以預儲存重建匯總資料表通常比較好

#### 使用UNION陳述反轉非正規化資料
* UNION查詢中的每個SELECT陳述必須有相同數量的欄
* 要控制資料的順序, 可以在最後的SELECT陳述後面加上 ORDER BY句子
* 若不要消除重複列或執行去重複, 以UNION ALL 替換 UNION
<hr>
<br>

## 彙整
#### 認識GROUP BY 如何運作
##### 更複雜的分群操作可使用ROLLUP, CUBE GROUPING SETS, 他讓FROM與WHERE 選取的資料以指定的分群集合與每個群的彙整分群 (note: MySql 不支援)
##### ROLLUP 可對群中的欄集合做額外的彙整

* WHERE 句子在彙整完成之前執行
* GROUP BY 句子彙整過濾後的資料集
* HAVING 句子過濾彙整後的資料集 (GROUP BY)
* ORDER BY 句子排序轉換過的資料集
* SELECT 句子有出現但沒有參加彙整函示或計算的欄必須出現在 GROUP BY 句子中
* GROUPING SETS 以及 ROLLUP 與 CUBE 能以一個查詢執行多個查詢的UNION

#### 利用GROUP BY/HAVING 解決複雜問題
* 使用WHERE句子在分群前過濾列, 使用HAVING 在分群後過濾
* HAVING 句子能過濾彙整表示式

#### 不用GROUP BY 找出最大或最小值
* 主資料表必須以 LEFT JOIN 連接本身
* 每個GROUP BY 句子用到的欄用於ON句子時使用等式( = ) 比較
* 每個 MAX()句子用到的欄用於ON句子時使用大於
* 用於ON句子的欄應該建立索引以提升效能, 特別是處理較大資料集時

#### 避免使用OUTER JOIN 的 COUNT() 錯誤
* 使用COUNT(*) 計算包括空直在內的所有列
* 使用COUNT(<欄名稱>) 計算欄飛NULL的列
* 有時子查詢, 甚至是關連子查詢比GROUP BY更有效率

#### 測試 HAVING COUNT(X) < 某數時包含零值列
* 使用INNER JOIN 不能找出零計數
* 過濾'左'連接的'右'側等於內連接, 將過濾複雜子查詢或使用ON述詞來過濾'右'側
* 預期計數1或以上時找出計數零可幫助識別資料的問題

#### 認識如何使用窗口函示
* 窗口函示知道周圍列, 可建構傳統彙整函示或陳述層級分群很難做到的累計或動態彙整
* 窗口函示是彙整不同或獨立資料的好方法
* 窗口函示可加上OVER句子而用於SUM(), COUNT(), AVG() 等彙總函式
* PARTITION BY 述詞可用於指定彙整表示式所套用的群
* ORDER BY 述詞影響彙整表示式計算列的順序

#### 產生列號與排名
* ROW_NUMBER(), RANK(), 與其他排名函示必須有窗口且不能沒有相對應的OVER句子
* 要考慮排名函式如何處理平。 若需要連續的排名, 應使用 DENSE_RANK()
* 這一類函示必須有ORDER_BY 述詞, 因為它影響排序或排名
<hr>
<br>

## 子查詢
#### 認識何時可以使用子查詢
* 可以在使用資料表或檢視表名稱或回傳資料表的函示或程序的地方使用資料表子查詢
* 可以在使用資料表子查詢與需要產生清單給 IN 或 NOT IN 述詞的地方使用回傳單欄的資料表子查詢 
* 純料子查詢可用於使用欄名稱的地方--SELECT 清單、SELECT清單中的表示式, 或作為比較述詞的一部分

#### 關聯子查詢
* 關聯子查詢使用WHERE或HAVING 句子中的參考, 該句子取決於嵌入子查詢的查詢中的值
* 非關聯子查詢查詢不依靠外層查詢並能獨立執行
* 非關聯子查詢通常作為FROM句子中的過濾後資料、IN述詞的單欄資料集, 或WHERE或HAVING句子中的比較述詞的純量值
* 關聯子查詢用於回傳純量值給SELECT句子、提供WHERE或HAVING句子中比比較述詞的測試單值, 或在EXISTS句子中提供測試集合
* 關聯子查詢不一定比其他方法慢且可能是回傳正確答案的唯一方法

<hr>
<br>

## 取得與分析元資料
#### 認識執行計畫如何運作
* 閱讀執行計畫時, 將他轉換成實際動作, 分析是否有索引沒用到並判斷為何不用
* 分析個別步驟並研判是否有效率。 注意效率受資料分布影響。 因此沒有所謂的'壞'操作。 相對的, 分析操作是否適合該查詢
* 不要因為一個查詢就加上索引來改善執行計畫, 必須從資料庫做全盤考慮以確保索引盡可能的通用
* 注意'大與小'狀況, 分佈不均的資料對同一個查詢會需要布農的最佳化, 
<font color="#cccㄑ">深红色文字</font>

